theory Nth
  use import list.List
  use import option.Option
  use import int.Int

  function nth(n:int)(l: list int) : option int = match l with
    | Nil -> None
    | Cons x r -> if n = 1 then Some x else nth (n-1) r
  end

end

module HeapModule
  use import int.Int
  use import list.List
  use import list.Length
  use import list.HdTlNoOpt
  use import list.Permut
  use import list.Append
  use import ref.Ref
  use import bool.Bool
  use import option.Option
  use import Nth
  use import int.ComputerDivision

  type heap_rep = { mutable size :int; data : list int }

  function to_abstract_heap(h: heap_rep) : list int
  axiom to_abastract_heap0: forall h : heap_rep . h.size = 0 ->  to_abstract_heap(h) = Nil
  axiom to_abastract_heap1:
    forall h : heap_rep .
      let h1 = {size= h.size-1; data=h.data} in
        h.size > 0 -> to_abstract_heap(h) = Cons (hd h1.data) (tl h1.data)


  exception Wrong_index

  predicate inv(h : heap_rep) =
    forall i : int . 0 <= i < length h.data

  let heap_left_position(i: int) : int
    requires { i > 0}
    =i * 2
  let heap_right_position(i :int) : int
    requires { i > 0}
    =heap_left_position(i) + 1

  let get_children_position(i : int) : (int, int)
    requires { i > 0}
    =(heap_left_position(i), heap_right_position(i))

  let heap_left(i :int)(h: heap_rep): option int
    requires{i > 0}
    = nth (heap_left_position i) h.data
  let heap_right(i :int)(h: heap_rep): option int
    requires{i > 0}
    = nth (heap_right_position i) h.data

  let heap_children(i:int)(h: heap_rep) : (option int, option int)
    requires{i > 0}
    = (heap_left i h, heap_right i h)


  predicate same_object (l1 : heap_rep) (l2:heap_rep) =
    permut l1.data l2.data


  function isNothing(i : option int) : bool=
    match i with
    | None -> True
    | Some _ -> False
    end

  let get(i : option int) : int
    requires { not (isNothing i) }
    =match i with
    | None -> 0
    | Some e -> e
    end


  axiom tail_size: forall l:list int . length (tl l) = (length l) - 1

  let rec take(l : list int)(i :int) : list int
  requires { 0 <= i <= length l } (** ensure i < length i **)
  variant { i }
  ensures { i = 0 -> Nil = result /\ i > 0 -> length result = i }
  = if i = 0 then begin
      Nil
    end else begin
      Cons (hd l) (take (tl l) (i-1))
    end

  let rec drop(l : list int)(i :int) : list int
  requires { i < length l /\ i >= 0}
  variant { i }
  ensures { i = 0 -> result = l /\ i > 0 -> (length l) - i = length result }
  = if i = 0 then begin
      l
    end else begin
      (take (tl l) (i-1))
    end

  let swap_helper(i:int)(j:int)(h:heap_rep): list int
    requires { i <= j }
    requires { i <= length h.data /\ j <= length h.data}
    ensures { same_object (old h) h }
    raises { Wrong_index -> forall i: int. i >= (div (length h.data) 2) }
    (** then we have to say that each element will be equal except the one in i and j *)
    = if (isNothing (nth i h.data))  then raise Wrong_index
      else if (isNothing (nth j h.data))  then raise Wrong_index
      else begin
        let start = (take h.data (i-1)) in
        let middle = (take (drop h.data i) (j-i-1)) in
        let _end = (drop h.data j) in
        let aj = (get (nth j h.data)) in
        let ai = (get (nth i h.data)) in
          (start ++ (Cons aj Nil) ++ middle ++ (Cons ai Nil) ++ _end)
      end

  let swap(i:int)(j:int)(h:heap_rep):heap_rep
    = let x = ref 0 in
      let y = ref 0 in
      try
        if i <= j then begin
          x := i; y := j
        end else begin
          x := j; y := i
        end;
        let l = (swap_helper !x !y h) in
          {size = length l; data = l}
      with Wrong_index -> { size = h.size; data = h.data}
      end
end
