theory Nth
  use import list.List
  use import option.Option
  use import int.Int

  function nth(n:int)(l: list int) : option int = match l with
    | Nil -> None
    | Cons x r -> if n = 1 then Some x else nth (n-1) r
  end
end

theory NthNoOpt

  use export list.List
  use import int.Int

  function nthNoOpt (n: int) (l: list 'a) : 'a

  axiom nth_cons_0: forall x:'a, r:list 'a. nthNoOpt 1 (Cons x r) = x
  axiom nth_cons_n: forall x:'a, r:list 'a, n:int.
    n > 1 -> nthNoOpt n (Cons x r) = nthNoOpt (n-1) r

end

module HeapModule
  use import int.Int
  use import list.List
  use import list.Length
  use import list.HdTlNoOpt
  use import list.Permut
  use import list.Append
  use import ref.Ref
  use import bool.Bool
  use import option.Option
  use import Nth
  use import NthNoOpt
  use import int.ComputerDivision

  type heap_rep = { mutable size :int; data : list int }

  function to_abstract_heap(h: heap_rep) : list int
  axiom to_abastract_heap0: forall h : heap_rep . h.size = 0 ->  to_abstract_heap(h) = Nil
  axiom to_abastract_heap1:
    forall h : heap_rep .
      let h1 = {size= h.size-1; data=h.data} in
        h.size > 0 -> to_abstract_heap(h) = Cons (hd h1.data) (tl h1.data)

  predicate invariant_size_heap (h: heap_rep)=
    0 <= h.size <= length(h.data)

  exception Wrong_index

  predicate inv(h : heap_rep) =
    forall i : int . 0 <= i < length h.data


    function left(i : int) : int = i*2
    function right(i : int) : int = i*2+1

    axiom increase_left: forall i :int . i < left i
    axiom increase_right: forall i :int . i < right i

  let heap_left_position(i: int) : int
    requires { i > 0}
    ensures { result = left(i)}
    =i * 2
  let heap_right_position(i :int) : int
    requires { i > 0}
    ensures { result =  right(i) }
    =heap_left_position(i) + 1

  let get_children_position(i : int) : (int, int)
    requires { i > 0}
    ensures { result = (left i, right i)}
    =(heap_left_position(i), heap_right_position(i))

  let heap_left(i :int)(h: heap_rep): option int
    requires{i > 0}
    ensures { result = nth (left i) h.data}
    = nth (heap_left_position i) h.data

  let heap_right(i :int)(h: heap_rep): option int
    requires{i > 0}
    ensures { result = nth ( right i) h.data}
    = nth (heap_right_position i) h.data

  let heap_children(i:int)(h: heap_rep) : (option int, option int)
    requires{i > 0}
    ensures{ result = (nth (left i) h.data, nth (right i) h.data)}
    = (heap_left i h, heap_right i h)


  function isNothing(i : option int) : bool=
    match i with
    | None -> True
    | Some _ -> False
    end

  let get(i : option int) : int
    requires { not (isNothing i) }
    =match i with
    | None -> 0
    | Some e -> e
    end

  (** We need this axiom to ensure the length decreases with the call of tail **)
  axiom tail_size: forall l:list int . length (tl l) = (length l) - 1

  let rec take(l : list int)(i :int) : list int
  requires { 0 <= i <= length l } (** ensure i < length i **)
  variant { i }
  ensures { i = 0 -> Nil = result /\ i > 0 -> length result = i }
  = if i = 0 then begin
      Nil
    end else begin
      Cons (hd l) (take (tl l) (i-1))
    end

  let rec drop(l : list int)(i :int) : list int
  requires { i < length l /\ i >= 0}
  variant { i }
  ensures { i = 0 -> result = l /\ i > 0 -> (length l) - i = length result }
  = if i = 0 then begin
      l
    end else begin
      (take (tl l) (i-1))
    end


    predicate same_object (l1 : heap_rep) (l2:heap_rep) =
      permut l1.data l2.data

  let swap_helper(i:int)(j:int)(h:heap_rep): list int
    requires { i <= j }
    requires { i <= length h.data /\ j <= length h.data}
    ensures { same_object (old h) h }
    ensures { nth i (old h.data) = nth j h.data /\ nth j (old h.data) = nth i h.data }
    ensures { forall k : int . ( 0 <= k <= length(h.data) /\ not (k = i \/ k = j) ) -> nth k (old h.data) = nth k h.data }
    raises { Wrong_index -> forall i: int. i >= (div (length h.data) 2) }
    (** then we have to say that each element will be equal except the one in i and j *)
    = if (isNothing (nth i h.data))  then raise Wrong_index
      else if (isNothing (nth j h.data))  then raise Wrong_index
      else begin
        let start = (take h.data (i-1)) in
        let middle = (take (drop h.data i) (j-i-1)) in
        let _end = (drop h.data j) in
        let aj = (get (nth j h.data)) in
        let ai = (get (nth i h.data)) in
          (start ++ (Cons aj Nil) ++ middle ++ (Cons ai Nil) ++ _end)
      end

  let swap(i:int)(j:int)(h:heap_rep):heap_rep
    ensures { same_object (old h) h }
    ensures { nth i (old h.data) = nth j h.data /\ nth j (old h.data) = nth i h.data }
    ensures { forall k : int . ( 0 <= k <= length(h.data) /\ not (k = i \/ k = j) ) -> nth k (old h.data) = nth k h.data }
    = let x = ref 0 in
      let y = ref 0 in
      try
        if i <= j then begin
          x := i; y := j
        end else begin
          x := j; y := i
        end;
        assert{ !x <= !y };
        let l = (swap_helper !x !y h) in
          {size = length l; data = l}
      with Wrong_index -> { size = h.size; data = h.data}
      end

    let indexOfMax(i : int)(h:heap_rep): int
    requires { 0 <= i <= length h.data }
    ensures { 0 <= result <= length h.data }
    ensures { (nthNoOpt result h.data >= nthNoOpt i h.data)
      /\ (nthNoOpt result h.data >= nthNoOpt (i*2) h.data)
      /\ (nthNoOpt result h.data >= nthNoOpt (i*2+1) h.data) }
    = let (l,r) =  heap_children i h    in
      let root = get (nth i h.data)     in
      if root >= get l && root >= get r then
        i
      else if get l >= get r then
        heap_left_position i
      else
        heap_right_position i

    function isHeap(i : int)(h :heap_rep): bool
    = forall i : int . (0 <= i <= length h.data) /\ (
      i > (div (length h.data) 2) -> True
      /\
      i <= (div (length h.data) 2) ->
        (nthNoOpt i h.data) >= (nthNoOpt (left i) h.data) /\ (nthNoOpt i h.data) >= (nthNoOpt (right i) h.data)
    )

    let rec heapify (i : int)(h: heap_rep): heap_rep
    variant { (length h.data)-i }
    ensures { isHeap i h }
    = if length h.data = 0 then
        { size = 0; data = Nil }
      else let m = (indexOfMax i h) in
        if m = i then
          { size = h.size; data = h.data }
        else
          heapify m (swap i m h)


end
